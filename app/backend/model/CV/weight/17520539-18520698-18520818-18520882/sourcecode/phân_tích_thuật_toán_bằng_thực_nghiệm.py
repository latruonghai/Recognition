# -*- coding: utf-8 -*-
"""Phân tích thuật toán bằng thực nghiệm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FJsOEEykYRj0wU7_yJl3Zo4pAq8F5Ow-

*   17520539 Lê Hưng
*   18520882 Dương Lê Tường Khang
*   18520698 Lã Trường Hải
*   18520818 Bùi Đào Gia Huy

**1. Cấu hình máy tính dùng để tạo file thực nghiệm**

**2. Tìm hệ số cho các lớp hàm riêng biệt**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from time import time
import pickle
import json
import queue
np.set_printoptions(precision=33)

"""**Xay dung ham**

#Create dataset
"""

class Data:
  
  def __init__(self, time, name, v=12, t=1.09):
    # self.V = V
    self.v = v
    self.t = t
    self.INF = int(1e9)
    self.name = name
    # # self.path, self.dis = self.create()
    self.time = time
    self.graph = {}

  def create(self, V):
    INF = self.INF
    path = np.zeros((V,V))
    dis = np.zeros((V, V))
    Graph = np.random.randint(0, 10, size = (V,V))
    edge = 0
    #print(Graph)
    #dis = np.copy(Graph)
    # for i in range(V):
    #   for j in range(V):
    #     dis[i][j] = INF if i!=j and Graph[i][j]==0 else Graph[i][j]
    dis = np.where(Graph!=0, Graph, INF)
    #print(dis)
    for i in range(V):
      dis[i][i] = 0
      for j in range(V):
        if dis[i][j] != INF and i!=j:
          path[i][j] = i
          edge += 1
        else:
          path[i][j] = -1
    return path.astype(np.int) , dis.astype(np.int), edge

  def dataset(self):
    V = []
    v = self.v
    for i in range(self.time):
      V.append(v)
      path, dis, edge = self.create(v)
      # print(dis)
      # start = time()
      # dis, path = floyd(dis, v, path)
      # end = time() - start
      self.graph[str(i)] = {'path': path, 'dis': dis, 'edge': edge, 'v': v}
      # times.append(end)
      v*=self.t
      v = int(v)
    with open(self.name, 'wb') as f:
      pickle.dump(self.graph,f)

if __name__ == "__main__":
  data = Data(30, 'floyd_path.pkl')
  data.dataset()

""" with open('floyd_path.pkl' , 'rb+') as f:
  data = pickle.load(f)
a = list(data.values())[0]
a """

"""# Convert Data
* Convert to Dijsktra
* Convert to Bellman
"""

# INF = int(1e9)
# MAX = 105
# class Node:
#   def __init__(self, id, dis):
#     self.id = id
#     self.dis = dis
#   def __lt__(self, other):
#     return self.dis <= other.dis

# class edge:
#   def __init__(self, source, target, weight):
#     self.source = source
#     self.target = target
#     self.weight = weight

# def convert(data, destination=None, name=None):
#   if destination == "dijsktra":
#     new_dijsktra = {}
#     dem = 0
#     for vertices, gr in data.items():
#       n = int(gr['v'])
#       graph = [[] for _ in range(n+5)]
#       dist = [INF for _ in range(n+5)]
#       path = [-1 for _ in range(n+5)]
#       dis = np.copy(gr['dis'])
#       # path = gr['path']
#       for i in range(dis.shape[0]):
#         for j in range(dis.shape[1]):
#           if dis[i][j] != 0 and dis[i][j]!= INF:
#             graph[i].append(Node(j, dis[i,j]))
#       new_dijsktra[str(dem)] = {'graph': graph, 'path': path, 'dis': dist, 'edge': gr['edge'], 'v': n}
#       dem+=1
#     if name !=None:  
#       with open(name, 'wb') as f:
#         pickle.dump(new_dijsktra, f)
#     print("Done")
#     return new_dijsktra

#   elif destination == "bellman":
#     new_bellman = {}
#     dem = 0
#     for vertices, gr in data.items():
#       graph = []
#       dist = [INF for _ in range(MAX)]
#       path = [-1 for _ in range(MAX)]
#       dis = gr['dis']
#       for i in range(dis.shape[0]):
#         for j in range(dis.shape[1]):
#           if dis[i][j] != 0 and dis[i][j] != INF:
#             graph.append(edge(i, j, dis[i][j]))
#             # e+=1
#       new_bellman[str(dem)] = {'graph': graph, 'path': path, 'dis': dist, 'edge': gr['edge'], 'v': int(gr['v'])}
#       # print(e == gr['edge'])
#       dem += 1
#     if name != None:
#       with open(name, 'wb') as f:
#         pickle.dump(new_bellman, f)
#     print('Done')
#     return new_bellman
  # elif destination==None:
  #   raise  NotInValid("Your 'destination' variable is invalid")

new = convert(data, destination='bellman', name='bellman_graph.pkl')
c = convert(data, destination='dijsktra', name='dijsktra_graph.pkl')

"""# Create Data"""

def createData(namefile='dijsktra_graph.pkl'):
  with open(namefile, 'rb+') as f:
    graph = pickle.load(f)
  return graph

if __name__ == "__main__":
  graph_floyd, graph_dijsktra, graph_bellman =createData(namefile='floyd_path.pkl'), createData(), createData(namefile='bellman_graph.pkl')

list(graph_dijsktra.values())[0]

"""#Floyd Warshall"""

# class Floyd:
#   def __init__(self, data):
#     # self.V = V
#     self.data = data.items()
#     self.size, self.V, self.times, self.edge = [], [], [], []

#   def floyd(self, dis, V, path):
#     size = 0
#     # print(dis)
#     for k in range(V):
#       for i in range(V):
#         for j in range(V):
#           if dis[i][j] > dis[i][k] + dis[k][j]:
#             dis[i][j] = dis[i][k] + dis[k][j]
#             path[i][j] = path[k][j]
#             size += dis[i][j].__sizeof__() + path[i][j].__sizeof__() 
#             # print('OK')
#     # size = dis.__sizeof__() + path.__sizeof__()    
#     return dis, path, size

#   def findPath(self):
#     # V, times = [], []
#     for i, gr in self.data:
      
#       path, dis, edge, v = np.copy(gr['path']), np.copy(gr['dis']), np.copy(gr['edge']), np.copy(gr['v'])
#       self.V.append(v)
#       self.edge.append(edge)
#       #print(dis)
#       start = time()
#       dis, path, size = self.floyd(dis, int(v), path)
#       end = time() - start
#       self.size.append(size)
#       self.times.append(end)
#     # print(V, times)
#     print(self.size)
#     print("Done")
  
#   def save(self, name):
#     self.findPath()
#     df = pd.DataFrame({'n': self.V, 't': self.times, 'edge': self.edge, 'size': self.size})
#     df.to_csv(name, header = True, index = None)

# if __name__ == "__main__":
#   # V, times = [],[]
#   # v = 12
#   # for i in range(40):
#   #   print(v)
#   #   V.append(v)
#   #   path, dis = create(v)
#   #   start = time()
#   #   dis, path = floyd(dis, v, path)
#   #   end = time() - start
#   #   times.append(end)
#   #   v*=1.09
#   #   v = int(v)
#   # print(V, times)
#   # path, dis = create(5)
#   # print('Path:\n{}\nDistance:\n{}'.format(path, dis))
#   floyd  = Floyd(graph_floyd)
#   floyd.save('/content/data/floyd_ThucNghiem.csv')

"""#Dijsktra"""

# class Dijsktra(Floyd):

#   def __init__(self, data=None):
#     super().__init__(data)

#   def dijkstra(self, s, graph, dist, path):
#     pq = queue.PriorityQueue()
#     pq.put(Node(s, 0))
#     dist[s] = 0
#     size = 0
#     while pq.empty() == False:
#       top = pq.get()
#       u = top.id
#       w = top.dis
#       if dist[u] != w:
#         continue
#       for neighbor in graph[u]:
#         if w + neighbor.dis < dist[neighbor.id]:
#           dist[neighbor.id] = w + neighbor.dis
#           pq.put(Node(neighbor.id, dist[neighbor.id]))
#           path[neighbor.id] = u
#           size += path[neighbor.id].__sizeof__() + dist[neighbor.id].__sizeof__()
#     return path, size
#   def findPath(self):
#     # V, times = [], []
#     for v, gr in self.data:
      
#       graph, edge, v_ = np.copy(gr['graph']), np.copy(gr['edge']), np.copy(gr['v'])
#       # v_ = v
#       self.V.append(v_)
#       self.edge.append(edge)
#       ends = 0
#       sizes = 0
#       for s in range(v_):
#         path, dist = np.copy(gr['path']), np.copy(gr['dis'])
#         start = time()
#         path, size = self.dijkstra(s, graph, dist, path)
#         end = time() - start
#         ends+=end
#         sizes+=size
#         # print('Dinh:', s)
#         # for d in range(s):
#         #   if d!=s:
#         #     print(path[:v_])
#         #     break
#       # end = time() - start
#       self.times.append(ends)
#       self.size.append(sizes)
#     print(self.size)

# if __name__ == "__main__":
#   graph = Dijsktra(graph_dijsktra)
#   graph.save('data/dijsktra_ThucNghiem.csv')

"""# Bellman

"""

# class Bellman(Floyd):

#   def __init__(self, data):
#     super().__init__(data)
  
#   def bellman(self, s, dist, path, graph, n, m):
#     dist[s] = 0
#     size = 0
#     for i in range(1, n):
#       for j in range(m):
#         u = graph[j].source
#         v = graph[j].target
#         w = graph[j].weight
#         if dist[u]!=INF and dist[u] + w < dist[v]:
#           dist[v] = dist[u] + w
#           path[v] = u
#           size += dist[v].__sizeof__() + path[v].__sizeof__()
#     return path, size

#   def findPath(self):
#     for v, gr in self.data:
      
#       graph, edge, v_ = np.copy(gr['graph']), gr['edge'], gr['v']
#       self.V.append(v_)
#       self.edge.append(edge)
#       ends = 0
#       sizes = 0
#       for s in range(v_):
#         path, dist = np.copy(gr['path']), np.copy(gr['dis'])
#         start = time()
#         path, size = self.bellman(s, dist, path,graph, v_, edge)
#         end = time() - start
#         ends += end
#         sizes+=size
      
#       self.times.append(ends)
#       self.size.append(sizes)
#     print(self.size)

# if __name__ == "__main__":
#   bellman = Bellman(graph_bellman)
#   bellman.save('/content/data/bellman_ThucNghiem.csv')

"""# Read Dataset"""

# namefile1 = 'data_new/floyd_time_ThucNghiem.csv'
# namefile2 = 'data_new/bellman_time_ThucNghiem.csv'
# namefile3 = 'data_new/dijsktra_time_ThucNghiem.csv'

# """##  Đọc dataset Floyd

# print(data['n'][0:55].values)
# print(X0)
# """

# data=pd.read_csv('/content/data/floyd_ThucNghiem.csv')[0:50]
# ##print(data)
# X0=data['n'].values.reshape(-1,1)
# Y=data['t'].values
# edge = data['edge'].values.reshape(-1, 1)
# plt.scatter(X0, Y)

# def coef(X):
#     regr=LinearRegression().fit(X, Y)
#     a = round(regr.coef_[0],19) if regr.coef_[0]!=0.0 else 1.0
#     plt.plot(X, Y, '.', X, a*X, '.')
#     return a

# """
# **e*v^2**"""

# X=X0**2 * edge
# a=coef(X)
# data['{}*e*v^2'.format(a)]=a*X
# data['e*v^2 squared_error']=(data['{}*e*v^2'.format(a)]-Y)**2
# data[['n','t','edge', '{}*e*v^2'.format(a),'e*v^2 squared_error']].head()

# """
# **sqrt(n)**"""

# X=np.sqrt(X0)
# a=coef(X)
# data['{}*sqrt(n)'.format(a)]=a*X
# data['sqrt(n) squared_error']=(data['{}*sqrt(n)'.format(a)]-Y)**2
# data[['n','t','{}*sqrt(n)'.format(a),'sqrt(n) squared_error']].head()

# """**log(n)**"""

# X=np.log2(X0)
# a=coef(X)
# data['{}*log(n)'.format(a)]=a*X
# data['log(n) squared_error']=(data['{}*log(n)'.format(a)]-Y)**2
# data[['n','t','{}*log(n)'.format(a),'log(n) squared_error']].head()

# """**n**"""

# a=coef(X0)
# data['{}*n'.format(a)]=a*X0
# data['n squared_error']=(data['{}*n'.format(a)]-Y)**2
# data[['n','t','{}*n'.format(a),'n squared_error']].head()

# """**elog(v)**"""

# X=edge*np.log2(X0)
# # print(X)
# a=coef(X)
# data['{}*vlog(e)'.format(a)]=a*X
# data['vlog(e) squared_error']=(data['{}*vlog(e)'.format(a)]-Y)**2
# data[['n','t','{}*vlog(e)'.format(a),'vlog(e) squared_error']].head()

# """**n^3**"""

# X=X0**3
# a=coef(X)
# data['{}*n^3'.format(a)]=np.round(a*X,3)
# data['n^3 squared_error']=(data['{}*n^3'.format(a)]-Y)**2
# data[['n','t','{}*n^3'.format(a),'n^3 squared_error']].head()

# """**n^2**"""

# X=X0**2
# a=coef(X)
# data['{}*n^2'.format(a)]=np.round(a*X,3)
# data['n^2 squared_error']=(data['{}*n^2'.format(a)]-Y)**2
# data[['n','t','{}*n^2'.format(a),'n^2 squared_error']].head()

# """**Tổng quát**"""

# MSE_sqrt=np.average(data['sqrt(n) squared_error'])
# MSE_log=np.average(data['log(n) squared_error'])
# MSE_n=np.average(data['n squared_error'])
# MSE_nlog=np.average(data['vlog(e) squared_error'])
# MSE_n3=np.average(data['n^3 squared_error'])
# MSE_mn2=np.average(data['e*v^2 squared_error'])
# MSE_n2=np.average(data['n^2 squared_error'])
# # MSE_n2=np.average(data['n^2 squared_error'])
# data = data.append({'n':'MSE','sqrt(n) squared_error':MSE_sqrt,'log(n) squared_error':MSE_log,'n squared_error':MSE_n,'vlog(e) squared_error':MSE_nlog,'n^3 squared_error':MSE_n3, 'n^2 squared_error':MSE_n2,'e*v^2 squared_error':MSE_mn2},ignore_index=True)

# """file kết quả"""

# data.to_csv(namefile1, index=False, header = True,)

# data

"""##  Đọc dataset bellman

print(data['n'][0:55].values)
print(X0)
"""

data=pd.read_csv('/content/data/bellman_ThucNghiem.csv')[0:50]
##print(data)
# namefile = 'data_new/bellman_size_ThucNghiem.csv'
X0=data['n'].values.reshape(-1,1)
Y=data['t'].values
edge = data['edge'].values.reshape(-1, 1)
plt.scatter(X0, Y)

def coef(X):
    regr=LinearRegression().fit(X, Y)
    a = round(regr.coef_[0],19) if regr.coef_[0]!=0.0 else 1.0
    plt.plot(X, Y, '.', X, a*X, '.')
    return a



"""
**e*v^2**"""

X=np.sqrt(X0)
len(X)

X=X0**2 * edge
a=coef(X)
data['{}*e*v^2'.format(a)]=a*X
data['e*v^2 squared_error']=(data['{}*e*v^2'.format(a)]-Y)**2
data[['n','t','edge', '{}*e*v^2'.format(a),'e*v^2 squared_error']].head()

"""
**sqrt(n)**"""

X=np.sqrt(X0)
len(X)

X=np.sqrt(X0)
a=coef(X)
data['{}*sqrt(n)'.format(a)]=a*X
data['sqrt(n) squared_error']=(data['{}*sqrt(n)'.format(a)]-Y)**2
data[['n','t','{}*sqrt(n)'.format(a),'sqrt(n) squared_error']].head()

"""**log(n)**"""

X=np.log(X0)
len(X)

X=np.log2(X0)
a=coef(X)
data['{}*log(n)'.format(a)]=a*X
data['log(n) squared_error']=(data['{}*log(n)'.format(a)]-Y)**2
data[['n','t','{}*log(n)'.format(a),'log(n) squared_error']].head()

"""**n**"""

a=coef(X0)
data['{}*n'.format(a)]=a*X0
data['n squared_error']=(data['{}*n'.format(a)]-Y)**2
data[['n','t','{}*n'.format(a),'n squared_error']].head()

"""**elog(v)**"""

X=edge*np.log2(X0)
# print(X)
a=coef(X)
data['{}*vlog(e)'.format(a)]=a*X
data['vlog(e) squared_error']=(data['{}*vlog(e)'.format(a)]-Y)**2
data[['n','t','{}*vlog(e)'.format(a),'vlog(e) squared_error']].head()

"""**n^3**"""

X=X0**3
a=coef(X)
data['{}*n^3'.format(a)]=np.round(a*X,3)
data['n^3 squared_error']=(data['{}*n^3'.format(a)]-Y)**2
data[['n','t','{}*n^3'.format(a),'n^3 squared_error']].head()

"""**n^2**"""

X=X0**2
a=coef(X)
data['{}*n^2'.format(a)]=np.round(a*X,3)
data['n^2 squared_error']=(data['{}*n^2'.format(a)]-Y)**2
data[['n','t','{}*n^2'.format(a),'n^2 squared_error']].head()

"""**Tổng quát**"""

MSE_sqrt=np.average(data['sqrt(n) squared_error'])
MSE_log=np.average(data['log(n) squared_error'])
MSE_n=np.average(data['n squared_error'])
MSE_nlog=np.average(data['vlog(e) squared_error'])
MSE_n3=np.average(data['n^3 squared_error'])
MSE_mn2=np.average(data['e*v^2 squared_error'])
MSE_n2=np.average(data['n^2 squared_error'])
# MSE_n2=np.average(data['n^2 squared_error'])
data = data.append({'n':'MSE','sqrt(n) squared_error':MSE_sqrt,'log(n) squared_error':MSE_log,'n squared_error':MSE_n,'vlog(e) squared_error':MSE_nlog,'n^3 squared_error':MSE_n3, 'n^2 squared_error':MSE_n2,'e*v^2 squared_error':MSE_mn2},ignore_index=True)

"""file kết quả"""

data.to_csv(namefile2, index=False, header = True,)

data

"""##  Đọc dataset dijsktra

print(data['n'][0:55].values)
print(X0)
"""

data=pd.read_csv('/content/data/dijsktra_ThucNghiem.csv')[0:50]
##print(data)
# namefile = 'data_new/dijsktra_size_ThucNghiem.csv'
X0=data['n'].values.reshape(-1,1)
Y=data['t'].values
edge = data['edge'].values.reshape(-1, 1)
plt.scatter(X0, Y)

def coef(X):
    regr=LinearRegression().fit(X, Y)
    a = round(regr.coef_[0],19) if regr.coef_[0]!=0.0 else 1.0
    plt.plot(X, Y, '.', X, a*X, '.')
    return a

"""
**e*v^2**"""

X=X0**2 * edge
a=coef(X)
data['{}*e*v^2'.format(a)]=a*X
data['e*v^2 squared_error']=(data['{}*e*v^2'.format(a)]-Y)**2
data[['n','t','edge', '{}*e*v^2'.format(a),'e*v^2 squared_error']].head()

"""
**sqrt(n)**"""

X=np.sqrt(X0)
len(X)

X=np.sqrt(X0)
a=coef(X)
data['{}*sqrt(n)'.format(a)]=a*X
data['sqrt(n) squared_error']=(data['{}*sqrt(n)'.format(a)]-Y)**2
data[['n','t','{}*sqrt(n)'.format(a),'sqrt(n) squared_error']].head()

"""**log(n)**"""



X=np.log(X0)
len(X)

X=np.log2(X0)
a=coef(X)
data['{}*log(n)'.format(a)]=a*X
data['log(n) squared_error']=(data['{}*log(n)'.format(a)]-Y)**2
data[['n','t','{}*log(n)'.format(a),'log(n) squared_error']].head()

"""**n**"""

a=coef(X0)
data['{}*n'.format(a)]=a*X0
data['n squared_error']=(data['{}*n'.format(a)]-Y)**2
data[['n','t','{}*n'.format(a),'n squared_error']].head()

"""**elog(v)**"""

X=edge*np.log2(X0)
# print(X)
a=coef(X)
data['{}*elog(v)'.format(a)]=a*X
data['elog(v) squared_error']=(data['{}*elog(v)'.format(a)]-Y)**2
data[['n','t','{}*elog(v)'.format(a),'elog(v) squared_error']].head()

"""**n^3**"""

X=X0**3
a=coef(X)
data['{}*n^3'.format(a)]=np.round(a*X,3)
data['n^3 squared_error']=(data['{}*n^3'.format(a)]-Y)**2
data[['n','t','{}*n^3'.format(a),'n^3 squared_error']].head()

"""**n^2**"""

X=X0**2
a=coef(X)
data['{}*n^2'.format(a)]=np.round(a*X,3)
data['n^2 squared_error']=(data['{}*n^2'.format(a)]-Y)**2
data[['n','t','{}*n^2'.format(a),'n^2 squared_error']].head()

"""**Tổng quát**"""

MSE_sqrt=np.average(data['sqrt(n) squared_error'])
MSE_log=np.average(data['log(n) squared_error'])
MSE_n=np.average(data['n squared_error'])
MSE_nlog=np.average(data['elog(v) squared_error'])
MSE_n3=np.average(data['n^3 squared_error'])
MSE_mn2=np.average(data['e*v^2 squared_error'])
MSE_n2=np.average(data['n^2 squared_error'])
# MSE_n2=np.average(data['n^2 squared_error'])
data = data.append({'n':'MSE','sqrt(n) squared_error':MSE_sqrt,'log(n) squared_error':MSE_log,'n squared_error':MSE_n,'elog(v) squared_error':MSE_nlog,'n^3 squared_error':MSE_n3, 'n^2 squared_error':MSE_n2,'e*v^2 squared_error':MSE_mn2},ignore_index=True)

"""file kết quả"""

data.to_csv(namefile3, index=False, header = True,)

data

"""#Temp"""

if __name__ == "__main__":
  data = Data(30, 'temp_path.pkl', 50, t=1)
  data.dataset()
  temp = createData('temp_path.pkl')
  temp2 = convert(temp, destination='dijsktra')
  temp3 = convert(temp, destination='bellman')
  bellman = Bellman(temp3)
  bellman.save('/content/data/bellman_temp_ThucNghiem.csv')
  floyd = Floyd(temp)
  floyd.save('/content/data/floyd_temp_ThucNghiem.csv')
  dijsktra = Dijsktra(temp2)
  dijsktra.save('/content/data/dijkstra_temp__ThucNghiem.csv')
  # print(list(temp2.values())[-2])

temp2

name = None
# print(name!=None)

a = {'a': 2, 'b':4}
for k, value in a.items():
  print(k, value)

a = np.array([215])
print(a)
b = a 
b[0] = 10
print('B:', b)
print('A:', a)

