\documentclass[a4paper]{article}
\usepackage{vntex}
%\usepackage[english,vietnam]{babel}
%\usepackage[utf8]{inputenc}

%\usepackage[utf8]{inputenc}
%\usepackage[francais]{babel}
\usepackage{a4wide,amssymb,epsfig,latexsym,multicol,array,hhline,fancyhdr}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{cases}
\usepackage{lastpage}
\usepackage[lined,boxed,commentsnumbered]{algorithm2e}
\usepackage{enumerate}
\usepackage{color}
\usepackage{graphicx}							% Standard graphics package
\usepackage{array}
\usepackage{tabularx, caption}
\usepackage{multirow}
\usepackage[framemethod=tikz]{mdframed}% For highlighting paragraph backgrounds
\usepackage{multicol}
\usepackage{rotating}
\usepackage{graphics}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{epsfig}
\usepackage{tikz}
\usepackage{listings}
\usetikzlibrary{arrows,snakes,backgrounds}
\usepackage{hyperref}
\hypersetup{urlcolor=blue,linkcolor=black,citecolor=black,colorlinks=true} 
%\usepackage{pstcol} 								% PSTricks with the standard color package

\newtheorem{theorem}{{\bf Định lý}}
\newtheorem{property}{{\bf Tính chất}}
\newtheorem{proposition}{{\bf Mệnh đề}}
\newtheorem{corollary}[proposition]{{\bf Hệ quả}}
\newtheorem{lemma}[proposition]{{\bf Bổ đề}}

\everymath{\color{blue}}
%\usepackage{fancyhdr}
\setlength{\headheight}{40pt}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{
 \begin{tabular}{rl}
    \begin{picture}(25,15)(0,0)
    \put(0,-8){\includegraphics[width=8mm, height=8mm]{logo_uit.png}}
    %\put(0,-8){\epsfig{width=10mm,figure=hcmut.eps}}
   \end{picture}&
	%\includegraphics[width=8mm, height=8mm]{logo_uit.png} & %
	\begin{tabular}{l}
		\textbf{\bf \ttfamily Trường Đại Học Công nghệ thông tin Tp.Hồ Chí Minh}\\
		\textbf{\bf \ttfamily Khoa Khoa Học Máy Tinh}
	\end{tabular} 	
 \end{tabular}
}
\fancyhead[R]{
	\begin{tabular}{l}
		\tiny \bf \\
		\tiny \bf 
	\end{tabular}  }
\fancyfoot{} % clear all footer fields
\fancyfoot[L]{\scriptsize \ttfamily Đồ án cuối kì môn Phân tích và Thiết kế Thuật toán}
\fancyfoot[R]{\scriptsize \ttfamily Trang {\thepage}/\pageref{LastPage}}
\renewcommand{\headrulewidth}{0.3pt}
\renewcommand{\footrulewidth}{0.3pt}


%%%
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
\makeatletter
\newcounter {subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection .\@alph\c@subsubsubsection}
\newcommand\subsubsubsection{\@startsection{subsubsubsection}{4}{\z@}%
                                     {-3.25ex\@plus -1ex \@minus -.2ex}%
                                     {1.5ex \@plus .2ex}%
                                     {\normalfont\normalsize\bfseries}}
\newcommand*\l@subsubsubsection{\@dottedtocline{3}{10.0em}{4.1em}}
\newcommand*{\subsubsubsectionmark}[1]{}
\makeatother

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=Python,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3,
	numbers=left,
	stepnumber=1,
	numbersep=1pt,    
	firstnumber=1,
	numberfirstline=true
}

\begin{document}

\begin{titlepage}
\begin{center}
ĐẠI HỌC QUỐC GIA THÀNH PHỐ HỒ CHÍ MINH \\
TRƯỜNG ĐẠI HỌC CÔNG NGHỆ THÔNG TIN \\
KHOA KHOA HỌC MÁY TÍNH 
\end{center}

\vspace{1cm}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=3cm]{logo_uit.png}
\end{center}
\end{figure}

\vspace{1cm}


\begin{center}
\begin{tabular}{c}
	\multicolumn{1}{l}{\textsc{\bf {\Large  BÁO CÁO ĐỒ ÁN CUỐI KỲ}}}\\
	~~\\
	\hline
	\\
	\multicolumn{1}{l}{\textbf{{\Large PHÂN TÍCH VÀ THIẾT KẾ THUẬT TOÁN}}}\\
	\\
	
	\textbf{{\Huge BÀI TOÁN QUY HOẠCH ĐỘNG VÀ}}\\
	\textbf{{\Huge ỨNG DỤNG}}\\
	
	\\
	\hline
\end{tabular}
\end{center}

\vspace{3cm}

\begin{table}[h]
\begin{tabular}{rrl}
\hspace{5 cm} & GVHD: &Ths.Phạm Nguyễn Trường An
\\
& Nhóm: & Dương Lê Tường Khang - 18520882
\\
& & Bùi Đào Gia Huy - 18520818 
\\
& & Lã Trường Hải - 18520698
\\
& & Lê Cao Hưng - 17520539
\end{tabular}
\end{table}

\begin{center}
{\footnotesize TP. HỒ CHÍ MINH, THÁNG 1/2021}
\end{center}
\end{titlepage}


\thispagestyle{empty}

\newpage
\tableofcontents

\newpage

\newpage
\section{Thuật toán Dijsktra}
\subsection{Giới thiệu}
Tham khảo: ``\textbf{link: https://vi.wikipedia.org/wiki/Thu\%E1\%BA\%ADt\_to\%C3\%A1n\_Dijkstra
}''
\subsection{Mô tả thuật toán}
Thuật toán Dijkstra là thuật toán tìm đường đi có chi phí nhỏ nhất từ một đỉnh đến tất cả các đỉnh còn lại trong độ thị có trọng số(trọng số không âm).

\textbf{Input:}
\begin{itemize}
    \item Ma trận kề.
\end{itemize}

\textbf{Output:}
\begin{itemize}
    \item Hai mảng gồm n phần tử lưu vết đường đi và chi phí ứng với mỗi đỉnh 
\end{itemize}
\textbf{Ví dụ:}
\begin{center}
    \includegraphics[]{graph_dijk.PNG}
\end{center}
Input: Ma trận kề
\begin{center}
    \includegraphics[scale=0.6]{dijk_matrix.PNG}
\end{center}
Output:
\begin{center}
    \includegraphics[scale=.8]{dijk_output.PNG}
\end{center}
Với mỗi đỉnh, xuất ra ma trận chứa đường đi từ đỉnh đó đến các đỉnh còn lại
\subsection{Cài đặt}

\itshape{Cài đặt thuật toán Dijsktra cho bài toán tìm đường đi ngắn nhất giữa mọi cặp đỉnh trong đồ thị.}
\subsubsection{Cài đặt hàm Dijsktra}
\begin{mdframed}[hidealllines=true,backgroundcolor=magenta!10]
		\begin{lstlisting}
def Dijsktra(s, graph, dist):
    pq = queue.PriorityQueue()
    pq.put(Node(s,0))
    dist[s] = 0
    while pq.empty() == False:
        top = pq.get()
        u = top.id
        w = top.dist
        if dist[u] != w:
            continue
        for neighbor in graph[u]:
            if w + neighbor.dist <  dist[neighbor.id]:
                dist[neighbor.id] = w + neighbor.dist
                pq.put(Node(neighbor.id, dist[neighbor.id]))
                
		\end{lstlisting}
	\end{mdframed}
\subsubsection{Cài đặt hoàn chỉnh}
\begin{mdframed}[hidealllines=true,backgroundcolor=magenta!10]
		\begin{lstlisting}
import queue
import sys
sys.stdin = open('D:/src/DA_algo/inp_d.txt', 'r')

MAX = 100
INF = int(1e9)

class Node:
    def __init__(self, id, dist):
        self.dist = dist
        self.id = id
    def __lt__(self, other):
        return self.dist <= other.dist

def Dijsktra(s, graph, dist):
    pq = queue.PriorityQueue()
    pq.put(Node(s,0))
    dist[s] = 0
    while pq.empty() == False:
        top = pq.get()
        u = top.id
        w = top.dist
        if dist[u] != w:
            continue
        for neighbor in graph[u]:
            if w + neighbor.dist <  dist[neighbor.id]:
                dist[neighbor.id] = w + neighbor.dist
                pq.put(Node(neighbor.id, dist[neighbor.id]))
                path[neighbor.id] = u

if __name__ == '__main__':
    n = int(input())
    graph = [[] for i in range(n+5)]
    
    for i in range(n):
        d = list(map(int, input().split()))
        for j in range(n):
            if d[j] > 0:
                graph[i].append(Node(j, d[j]))
    for s in range(n):
        dist = [INF for i in range(n+5)]
        path = [-1 for i in range(n+5)]
        Dijsktra(s, graph, dist)
        print("Dinh:", s)
        for d in range(n):
            if d != s:
                print(path[:n])
                break

		\end{lstlisting}
	\end{mdframed}
\subsection{Kiểm nghiệm tính đúng đắn}
Với đồ thị cho như hình dưới:
\begin{center}
    \includegraphics[]{graph_dijk.PNG}
\end{center}
Duyệt lần lượt từng đỉnh để tính khoảng cách ngắn nhất đến các đỉnh còn lại
\begin{itemize}
    \item Đỉnh 0:
    \begin{center}
        \includegraphics[scale=0.1]{0_dijk.jpg}
    \end{center}
    
    \item Đỉnh 1:
        \begin{center}
            \includegraphics[scale=0.1]{1_dijk.jpg}
        \end{center}
    \item Đỉnh 2:
        \begin{center}
            \includegraphics[scale=.1]{2_dijk.jpg}
        \end{center}
    \item Đỉnh 3:
        \begin{center}
            \includegraphics[scale=.1]{3_dijk.jpg}
        \end{center}
    \item Đỉnh 4:
        \begin{center}
            \includegraphics[scale=.1]{4_dijk.jpg}
        \end{center}
    \item Đỉnh 5:
        \begin{center}
            \includegraphics[scale=.1]{5_dijk.jpg}
        \end{center}
\end{itemize}
Kiểm tra kết quả với output của chương trình:
\begin{center}
   \includegraphics[]{dijk_output.PNG} 
\end{center}

\subsection{Độ phức tạp}
Tính toán độ phức tạp dựa trên hàm dijsktra cho bài toán tìm đường đi ngắn nhất giữa mọi cặp đỉnh trong đồ thị

Trong đó:
\begin{itemize}
    \item V: số đỉnh của đồ thị
    \item E: số cạnh của đồ thị
    \item S: tập hợp các đỉnh có đường đi ngắn nhất cuối cùng với đỉnh source được xác định
    \item Z: độ phức tạp của việc thêm 1 phần tử vào priority queue
\end{itemize}

Với mỗi đỉnh  $u\in V$ được thêm vào tập S duy nhất một lần, từng cạnh trong danh sách kề được thực hiện trong vòng lặp duy nhất 1 lần trong toàn bộ thuật toán. Do đó, tổng số cạnh là E nên có tổng cộng E lần lặp trong vòng while.

\begin{align*}
    T(n)&=\sum_{i=0}^{v}(3 + \sum_{}^{E}(Z + 1))\\
    &= V(3+EZ+E) \\
    &= 3V + 3EVZ + E
\end{align*}

Với độ phức tạp của việc thêm 1 phần tử vào priority queue là O(logN) với N là số phần tử trong hàng đợi ưu tiên.

Do đó, độ phức tạp của thuật toán là O(V(ElogV))

\subsection{Thực nghiệm}
\begin{itemize}
    \item Time Complexity
    \begin{center}
        \includegraphics[scale=.42]{dijsktra_time1.png}   
    \end{center}
    \item Space Comlexity
    \begin{center}
        \includegraphics[scale=.41]{dijsktra_size1.png}   
    \end{center}
\end{itemize}
\begin{align*}
    T(n)&=

\end{align*}


\section{Thuật toán Bellman Ford}
\subsection{Giới thiệu}
Tham khảo: ``\textbf{link: https://en.wikipedia.org/wiki/Bellman\%E2\%80\%93Ford\_algorithm
}''
\subsection{Mô tả bài toán}
Thuật toán Bellman-Ford là thuật toán tim đường đi có chi phí nhỏ nhất từ một đỉnh đến tất cả các đỉnh còn lại trong đồ thị  có hướng hoặc vô hướng, có trọng số(trọng số có thể dương hoặc âm).

\textbf{Input:}
\begin{itemize}
    \item Danh sách cạnh kề.
\end{itemize}

\textbf{Output:}
\begin{itemize}
    \item Hai mảng gồm n phần tử lưu vết đường đi cho mỗi đỉnh.
\end{itemize}

\textbf{Ví dụ:}
\begin{center}
    \includegraphics[scale=0.5]{bellman_graph.PNG}
\end{center}
Input: Danh sách cạnh kề và đỉnh xuất phát 0.
\begin{center}
    \includegraphics[scale=0.5]{bellman_list.PNG}
\end{center}
Output:
\begin{center}
    \includegraphics[scale=0.5]{bellman_all.png}
\end{center}
Với mỗi đỉnh, tương ứng 1 mảng path chứa đường đi từ đỉnh đó đến mọi đỉnh còn lại.
\subsection{Cài đặt}

\itshape{Cài đặt thuật toán Bellman Ford cho bài toán tìm đường đi ngắn nhất giữa mọi cặp đỉnh trong đồ thị.}

\subsubsection{Cài đặt hàm Bellman ford}

\begin{mdframed}[hidealllines=true,backgroundcolor=magenta!10]
		\begin{lstlisting}
def BellmanFord(s):
    dist[s] = 0
    for i in range(1, n):
        for j in range(m):
            u = graph[j].source
            v = graph[j].target
            w = graph[j].weight
            if dist[u] != INF and dist[u] + w < dist[v] :
                dist[v] = dist[u] + w
    return 
		\end{lstlisting}
	\end{mdframed}
\subsubsection{Cài đặt hoàn chỉnh}

\begin{mdframed}[hidealllines=true,backgroundcolor=magenta!10]
		\begin{lstlisting}
import sys
import queue
sys.stdin = open('D:/src/DA_algo/inp_bellman.txt', 'r')

INF = 10**9
MAX = 105

class edge:
    def __init__(self, source, target, weight):
        self.source = source
        self.target = target
        self.weight = weight


n, m = map(int, input().split())
#n, m: so dinh, so canh 
def BellmanFord(s, dist, path):
    dist[s] = 0
    for i in range(1, n):
        for j in range(m):
            u = graph[j].source
            v = graph[j].target
            w = graph[j].weight
            if dist[u] != INF and dist[u] + w < dist[v] :
                dist[v] = dist[u] + w
                path[v] = u
    return 

def traceback(path, source, destination):
    flag = destination
    res = []
    while flag != -1:
        res.append(flag)
        flag = path[flag]
    print("path: ", path[:n])
    '''
    for i in range(len(res)-1, 0, -1):
        print(res[i], end = '->')
    print(destination)
    '''
    return 
        
if __name__ == '__main__':
    
    graph = []
    #do thi dau vao
    for i in range(m):
        u, v, w = map(int, input().split())
        graph.append(edge(u, v, w))
    
    for s in range(n):
        dist = [INF for _ in range(MAX)]
        #mang chua trong so nho nhat tu dinh i den dinh j
        path = [-1 for _ in range(MAX)]
        #luu vet duong di
        res = BellmanFord(s, dist, path)
        
        print("Đỉnh: ", s)
        for d in range(n):
            if (d != s):
                #print("trong so duong di ngan nhat tu dinh{} den dinh {}: {} ".format(s, d, dist[d]))
                traceback(path, s, d)
                break
        
    
		\end{lstlisting}
	\end{mdframed}
	
\subsection{Kiểm nghiệm tính đúng đắn}
Khởi tạo input như hình:
\begin{center}
    \includegraphics[scale = 0.1]{correctness_bellman/init.jpg}
\end{center}
Duyệt qua từng đỉnh:

-Đỉnh 0:

\begin{itemize}
    \item i = 0:
    \begin{itemize}
        \item j = 0 - 1
            \begin{center}
                \includegraphics[scale = 0.3]{correctness_bellman/j0j1.jpg}
            \end{center}
        \item j = 2 - 3
            \begin{center}
                \includegraphics[scale = 0.3]{correctness_bellman/j2j3.jpg}
            \end{center}
        \item j = 4 - 5
            \begin{center}
                \includegraphics[scale = 0.3]{correctness_bellman/j4j5.jpg}
            \end{center}
    \end{itemize}
    \item i = 1 2:
    \begin{center}
        \includegraphics[scale = 0.3]{correctness_bellman/i123.jpg}
    \end{center}
    \item i = 2 3:
    \begin{center}
        \includegraphics[scale = 0.3]{correctness_bellman/i2_i3.jpg}
    \end{center}
\end{itemize}

- Với đỉnh 1 2 3:
\begin{center}
    \includegraphics[scale = 0.3]{correctness_bellman/vertex123.jpg}
\end{center}

- Với đỉnh 4 5:
\begin{center}
    \includegraphics[scale = 0.3]{correctness_bellman/vertex45.jpg}
\end{center}

So sánh với output của code:

\begin{center}
    \includegraphics[scale = 0.3]{bellman_all.png}
\end{center}
\subsection{Độ phức tạp}
Tính toán độ phức tạp của hàm bellman ford:

Với:
\begin{itemize}
    \item n: số đỉnh của đồ thị
    \item m: số cạnh của đồ thị
\end{itemize}

\begin{align*}
    T(n)&=\sum_{i=0}^{n}(\sum_{i=1}^{n}(\sum_{j=0}^{m}(3+5)))\\
    &= n(8mn - 8m) \\
    &= 8mn^2 - 8mn
\end{align*}

Do đó thuật toán thuộc độ phức tạp $O(mn^2)$

\subsection{Thực nghiệm}
\begin{itemize}
    \item Time Compexity
\end{itemize}
\begin{center}
    \includegraphics[scale=.45]{bellman_time1.png}
\end{center}
\begin{itemize}
    \item Space Compexity
\end{itemize}
\begin{center}
    \includegraphics[scale=.45]{bellman_size.png}
\end{center}

\section{Thuật toán Floyd-warshall}
\subsection{Giới thiệu}
Tham khảo: ``\textbf{link:https://vi.wikipedia.org/wiki/Thu\%E1\%BA\%ADt\_to\%C3\%A1n\_Floyd-Warshall}''


\subsection{Mô tả bài toán}
Tìm kiếm đường đi cho tất cả các đỉnh trên của đồ thị có hướng sao cho đường đi đến tất cả các cạnh là ngắn nhất.

Thuật toán Floyd-Warshall so sánh tất cả các đường đi có thể giữa từng cặp đỉnh. Nó là một dạng của quy hoạch động (Dynamic Programming). Đặt hàm adj(i,j,k) là đường đi ngắn nhất từ i đến j, chỉ dùng các đỉnh trong tập (1,2,…,k). Giả sử ta muốn tính adj(i,j,k+1). Với mỗi cặp đỉnh i và j, đường đi ngắn nhất có thể là: (1) đường đi chỉ sử dụng các đỉnh trong tập (1,…k) hoặc (2) đường đi từ i đến k+1 rồi từ k+1 đến j, cũng chỉ sử dụng các đỉnh trong tập (1,…k). Do vậy:

\begin{mdframed}[hidealllines=true,backgroundcolor=magenta!10]
		\begin{lstlisting}
		for k in range(N):
            for i in range(N):
                for j in range(N):
                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])
		\end{lstlisting}
	\end{mdframed}

Thông qua đó thu được kết quả là một ma trân chửa giá trị khoảng cách tương ứng giữa các đỉnh với nhau.

Vậy Input và Output của bài toán là:

\textbf{Input:}

\begin{itemize}
    \item Ma trận đường đi của đồ thị có hướng
\end{itemize}

\textbf{Output:}

\begin{itemize}
    \item Ma trận kết quả đường đi ngắn nhất theo từng đỉnh  đồ thị 
\end{itemize}
\textbf{Ví dụ:}
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.5]{floyd-warshall-algorithm2.png}
    \caption{Đồ Thị Hướng}
\end{figure}

\textbf{Input:}

Ma trận E:

\begin{tabular}{c |c | c | c | c}
     0 & 3 & 8 & inf & -4  \\
     inf & 0 & inf & 1 & 7  \\
     inf & 4 & 0 & inf & inf  \\
     2 & inf & -5 & 0 & inf  \\
     inf & inf & inf & 6 & 0  \\
\end{tabular}

Trong đó inf(infinite) là một số nguyên vô cùng lớn

\textbf{Output:}

Ma trận Đường Đi Ngắn Nhất:

\begin{tabular}{c |c | c | c | c}
     0 & 1 & 3 & 2 & 4  \\
     3 & 0 & 4 & 1 & -1  \\
     7 & 4 & 0 & 5 & 3  \\
     2 & -1 & -5 & 0 & -2  \\
     8 & 5 & 1 & 6 & 0  \\
\end{tabular}


\subsection{Mô tả bài toán ứng dụng thực tế - hệ thống giao thông}

Dựa trên thuật toán floyd warshall có thể xây dựng hệ thống giao thông với:

\begin{itemize}
    \item Đỉnh(node): biểu diễn cho các giao lộ trong thành phố
    \item Cạnh(edge): biểu diễn cho đoạn đường giữa 2 giao lộ
    \item trọng số: biểu diễn cho độ dài đường đi ( có thể thêm các yếu tố kẹt xe, cước phí vào trọng số)
\end{itemize}


\subsection{Công thức truy hồi}

\begin{subnumcases}{d_{(ij)}^{(k)}=}
    w(i,j) & $(k=0)$ \\
Min(d_{ij}^{(k-1)}, d_{ik}^{(k-1)} + d_{kj}^{(k-1)})  & còn lại   
\end{subnumcases}

Trong đó:

\begin{itemize}
    \item $d_{(ij)}^{(k)}$: trọng số của đường đi ngắn nhất từ đỉnh i đến đỉnh j với tập các đỉnh trung gian là \{1,2,3,4,...,k\}
    \item $w(i,j)$: trọng số của cạnh (i;j)
    \item $k$: số lượng đỉnh trung gian
\end{itemize}

\subsection{Cài đặt}
\subsubsection{Bottom - up}

\begin{itemize}
    \item V: số đỉnh của ma trận
    \item graph: ma trận đầu vào
    \item dist: trọng số đường đi ngắn nhất từ đỉnh i đến j
\end{itemize}


\begin{mdframed}[hidealllines=true,backgroundcolor=magenta!10]
		\begin{lstlisting}
		
        def floydwarshall(graph,dist):
            for i in range(V):
                for j in range(V):
                    dist[i][j] = graph[i][j]
            
            for k in range(V):
                for i in range(V):
                    for j in range(V):
                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
            return 
		\end{lstlisting}
	\end{mdframed}
\subsubsection{Cài đặt hoàn chỉnh}
\begin{mdframed}[hidealllines=true,backgroundcolor=magenta!10]
		\begin{lstlisting}

#V: số đỉnh input
#graph: ma trận đầu vào
import sys
sys.stdin = open('D:/src/DA_algo/inp.txt', 'r')


def floydwarshall(graph,dist, V, path):
    for i in range(V):
        for j in range(V):
            dist[i][j] = graph[i][j]
            if graph[i][j] != INF and i != j:
                path[i][j] = i
            else:
                path[i][j] = -1
    '''
    print("\nKẾT QUẢ MA TRẬN PATH TRƯỚC KHI CHẠY\n")
    for i in range(V):
        print(path[i])
    '''

    for k in range(V):
        for i in range(V):
            for j in range(V):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    path[i][j] = path[k][j]
    for i in range(V):
        if dist[i][i] < 0:
            return False
        
    return True 

#traceback

V = int(input())
graph = [[None for i in range(V)] for j in range(V)]
dist  = [[None for i in range(V)] for j in range(V)]
path = [[None for i in range(V)] for j in range(V)]
INF = int(1e9)
MAX = 100

for i in range(V):
    line = list(map(int, input().split()))
    for j in range(V):
        graph[i][j] = INF if line[j] == 0 and i!=j else line[j]
'''
for i in range(V):
    print(graph[i])
'''


floydwarshall(graph,dist, V, path)

'''
print("\nket qua ma tran dist\n")
for i in range(V):
    print(dist[i])
'''
print("\nkat qua ma tran path\n")

for i in range(V):
    print(path[i])

		\end{lstlisting}
	\end{mdframed}


\subsection{Kiểm tra tính đúng đắn}
Khởi tạo input như hình:

\begin{center}
    \includegraphics[scale=.1]{input.jpg}
\end{center}

Khởi tạo ma trận đầu vào như hình:

\begin{center}
    \includegraphics[scale=.1]{init.jpg}
    
\end{center}

Chạy tay các bước với k từ 0 -> 5 như bảng sau:

\begin{center}
    
    \includegraphics[scale=.1]{k0.jpg}
    \includegraphics[scale=.1]{k1.jpg}
    \includegraphics[scale=.1]{k2.jpg}


    \includegraphics[scale=.1]{k3.jpg}
    \includegraphics[scale=.1]{k4.jpg}
    \includegraphics[scale=.1]{k5.jpg}
\end{center}

Kết quả ở bảng 5 chính là output của bài toán.

Kiểm tra với output của bài toán bởi thuật toán bottom-up:

\begin{center}
    \includegraphics[scale = 1]{res.png}
\end{center}

\subsection{Độ phức tạp thuật toán}
Độ phức tạp của thuật toán Floyd-Warshall dựa trên code bottom-up

Với:
\begin{itemize}
    \item n: số đỉnh của đồ thị
    \item x: số đỉnh trung gian
\end{itemize}

Ta có:

\begin{align*}
    T(n)&=\sum_{k=0}^{n}(\sum_{i=0}^{n}(\sum_{j=0}^{n}2))\\
    &= 2(n^3)
\end{align*}
Do đó thuật toán thuộc lớp $O(n^3)$ với n là số đỉnh của đồ thị

\subsection{Thực nghiệm}

\begin{itemize}
    \item Khảo sát sự ảnh hưởng của số cạnh đến thời gian thực hiện
\end{itemize}

\begin{itemize}
    \item Time Complexity
    
    \begin{itemize}
        \item n: số đỉnh trong đồ thị
        \item t: thời gian thực hiện
    \end{itemize}

\end{itemize}

\begin{center}
    \includegraphics[scale=.42]{floyd_time1.png}
\end{center}

\begin{itemize}
    \item Space Complexity
\end{itemize}
\begin{center}
    \includegraphics[scale=.42]{floyd_size1.png}
\end{center}

\subsection{Sự ảnh hưởng của cạnh đến thời gian thực hiện}
Bảng sự ảnh hưởng của cạnh lên độ phức tạp của thuật toán

\begin{center}
    \includegraphics[]{Screenshot from 2021-02-03 23-16-14.png}
\end{center}

\begin{center}
    \includegraphics[]{edge.png}
\end{center}
Dựa vào đồ thị ta có:
\begin{itemize}
    \item Các điểm màu xanh là các thể hiện sự thay đổi của thời gian khi cạnh thay đổi $\xrightarrow[ ]{}$ thời gian có xu hướng giảm khi cạnh tăng.
 \item Tuy nhiên, các điểm dữ liệu xảy ra một cách ngẫu nhiên, không tuyến tính (mô hình Logistic Regression bị Underfitting). Do đó, không thể kết luận Floyd phụ thuộc vào giá trị của cạnh.
\end{itemize}

\section{Kết luận}
\begin{itemize}
    \item So sánh:
    
    Nhóm thực hiện so sánh giữa 3 thuật toán, áp dụng cho bài toán tìm đường đi ngắn nhất với mọi cặp đỉnh thuộc đồ thị

Trong đó:
\begin{itemize}
    \item V: số đỉnh thuộc đồ thị
    \item E: số cạnh thuộc đồ thị
\end{itemize}
    
    \begin{center}
        \includegraphics[scale = 0.5]{compare.png}
    \end{center}

        
    Từ kết quả thực nghiệm, cài đặt thuật toán dijsktra thu được thời gian thực thi nhỏ nhất.


    \item Nhận xét:

Qua đồ án môn học, nhóm tìm hiểu được:    
    \begin{itemize}
        \item Các bài toán về đồ thị: tìm đường đi ngắn nhất từ 1 đỉnh đến mọi đỉnh, đường đi giữa mọi cặp đỉnh.
        \item Các thuật toán liên quan về đường đi trong đồ thị: dijsktra, bellma-ford, floyd-warshall.
        \item Việc tính toán độ phức tạp của thuật toán và thực nghiệm theo phương pháp Machine Learning. 
        \item Tìm hiểu ứng dụng các thuật toán đó vào cuộc sống như: google map, hệ thống giao thông, ...
    \end{itemize}
\end{itemize}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{80}

\bibitem{algorithms}
algorithms
``\textbf{link: https://www.giaithuatlaptrinh.com}''

\end{thebibliography}
\end{document}